const Vulnerability = require('../models/Vulnerability');

// @desc    Ottieni tutte le vulnerabilità di un sottodominio
// @route   GET /api/subdomains/:subdomainId/vulnerabilities
exports.getVulnerabilitiesBySubdomain = async (req, res) => {
  try {
    const { severity, status } = req.query;
    
    let query = { subdomainId: req.params.subdomainId };
    
    if (severity) {
      query.severity = severity;
    }
    
    if (status) {
      query.status = status;
    }

    const vulnerabilities = await Vulnerability.find(query)
      .sort({ severity: 1, createdAt: -1 });
    
    res.json({
      success: true,
      count: vulnerabilities.length,
      data: vulnerabilities
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// @desc    Ottieni singola vulnerabilità
// @route   GET /api/vulnerabilities/:id
exports.getVulnerability = async (req, res) => {
  try {
    const vulnerability = await Vulnerability.findById(req.params.id)
      .populate({
        path: 'subdomainId',
        select: 'subdomain ipAddress',
        populate: {
          path: 'projectId',
          select: 'name domain client'
        }
      });
    
    if (!vulnerability) {
      return res.status(404).json({
        success: false,
        error: 'Vulnerabilità non trovata'
      });
    }

    res.json({
      success: true,
      data: vulnerability
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// @desc    Crea nuova vulnerabilità
// @route   POST /api/subdomains/:subdomainId/vulnerabilities
exports.createVulnerability = async (req, res) => {
  try {
    const vulnerabilityData = {
      ...req.body,
      subdomainId: req.params.subdomainId
    };

    const vulnerability = await Vulnerability.create(vulnerabilityData);
    
    res.status(201).json({
      success: true,
      data: vulnerability
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      error: error.message
    });
  }
};

// @desc    Aggiorna vulnerabilità
// @route   PUT /api/vulnerabilities/:id
exports.updateVulnerability = async (req, res) => {
  try {
    const vulnerability = await Vulnerability.findByIdAndUpdate(
      req.params.id,
      req.body,
      {
        new: true,
        runValidators: true
      }
    );

    if (!vulnerability) {
      return res.status(404).json({
        success: false,
        error: 'Vulnerabilità non trovata'
      });
    }

    res.json({
      success: true,
      data: vulnerability
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      error: error.message
    });
  }
};

// @desc    Elimina vulnerabilità
// @route   DELETE /api/vulnerabilities/:id
exports.deleteVulnerability = async (req, res) => {
  try {
    const vulnerability = await Vulnerability.findById(req.params.id);

    if (!vulnerability) {
      return res.status(404).json({
        success: false,
        error: 'Vulnerabilità non trovata'
      });
    }

    await vulnerability.deleteOne();

    res.json({
      success: true,
      data: {}
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// @desc    Ottieni statistiche vulnerabilità per progetto
// @route   GET /api/projects/:projectId/vulnerabilities/stats
exports.getVulnerabilityStats = async (req, res) => {
  try {
    const Subdomain = require('../models/Subdomain');
    
    // Ottieni tutti i sottodomini del progetto
    const subdomains = await Subdomain.find({ projectId: req.params.projectId });
    const subdomainIds = subdomains.map(s => s._id);
    
    // Ottieni tutte le vulnerabilità
    const vulnerabilities = await Vulnerability.find({ 
      subdomainId: { $in: subdomainIds } 
    });
    
    const stats = {
      total: vulnerabilities.length,
      bySeverity: {
        critical: vulnerabilities.filter(v => v.severity === 'critical').length,
        high: vulnerabilities.filter(v => v.severity === 'high').length,
        medium: vulnerabilities.filter(v => v.severity === 'medium').length,
        low: vulnerabilities.filter(v => v.severity === 'low').length,
        info: vulnerabilities.filter(v => v.severity === 'info').length
      },
      byStatus: {
        open: vulnerabilities.filter(v => v.status === 'open').length,
        fixed: vulnerabilities.filter(v => v.status === 'fixed').length,
        acceptedRisk: vulnerabilities.filter(v => v.status === 'accepted-risk').length,
        falsePositive: vulnerabilities.filter(v => v.status === 'false-positive').length
      }
    };
    
    res.json({
      success: true,
      data: stats
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};